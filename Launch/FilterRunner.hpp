#pragma once

#include <DisRegRep/Format.hpp>
#include <DisRegRep/ThreadPool.hpp>
#include <DisRegRep/Container/RegionMap.hpp>

#include <DisRegRep/Factory/RegionMapFactory.hpp>
#include <DisRegRep/Filter/RegionMapFilter.hpp>

#include "Utility.hpp"

#include <string>
#include <string_view>
#include <span>
#include <array>
#include <vector>
#include <any>

#include <filesystem>

namespace DisRegRep::Launch {

/**
 * @brief Run and benchmark filter.
 * Filter runner utilises parallel filter benchmarking,
 *	and hence certain lifetime guarantees should be made by the calling application
 *	until execution of filter has been synchronised.
*/
class FilterRunner {
public:

	/**
	 * @brief Information for sweeping a variable in a filter run.
	 * Region map factory and filter should remain valid until the end of filter execution.
	 * Additionally the array that holds pointers to filter should also be preserved until end of execution.
	*/
	struct SweepDescription {

		const RegionMapFactory* Factory;
		std::span<const RegionMapFilter* const> Filter;

		std::string UserTag;

	};

private:

	//Used for running a single invocation of filter.
	struct RunDescription {

		const RegionMapFactory& Factory;
		const RegionMapFilter& Filter;
		const std::string_view UserTag;

		RegionMap& Map;
		std::any& Histogram;

	};

	constexpr static size_t ThreadCount = 4u;

	std::filesystem::path ReportRoot;

	std::array<RegionMap, ThreadCount> Map;
	std::array<std::array<std::any, Utility::AllFilterTagSize>, ThreadCount> Histogram;/**< One histogram per thread per tag. */

	ThreadPool Worker;

	std::vector<std::future<void>> PendingTask;

	//Create a new report file from benchmark.
	template<typename Tag>
	void renderReport(Tag, const RunDescription&, auto&) const;

	template<typename Func>
	void runFilter(Func&&, const SweepDescription&);

public:

	/**
	 * @brief Initialise a filter runner.
	 * 
	 * @param test_report_dir The directory where test reports are stored.
	 * It's possible to place this directory with a common root path that is shared with other filter runners,
	 * this constructor ensures no filesystem race occurs.
	*/
	FilterRunner(const std::filesystem::path&);

	FilterRunner(const FilterRunner&) = delete;

	FilterRunner(FilterRunner&&) = delete;

	~FilterRunner() = default;

	/**
	 * @brief Wait for all filter works to finish.
	 * All object lifetime guarantees are lifted once this function returns.
	*/
	void waitAll();

	/**
	 * @brief Profile impact of runtime by varying radius.
	 * Memory lifetime guarantees:
	 * - `region_map`
	 * - The underlying array held by `radius_arr`
	 * 
	 * @param desc The description about the sweep.
	 * Region map factory in this function is used for providing test details,
	 * it will not be used to generate region map, as it should be provided by the application instead.
	 * @param region_map The region map generated by the application to be used.
	 * @param extent The extent of filter run area.
	 * @param radius_arr An array of radii to be run in order.
	*/
	void sweepRadius(const SweepDescription&, const RegionMap&, const Format::SizeVec2&,
		std::span<const Format::Radius_t>);

	/**
	 * @brief Profile impact of runtime by varying region count.
	 * Region map will be automatically regenerated using different region count.
	 * Memory lifetime guarantees:
	 * - The underlying array held by `region_count_arr`
	 * 
	 * @param desc The description about the sweep.
	 * @param extent The size of the filter area.
	 * @param radius The radius of filter kernel.
	 * @param region_count_arr An array of region count.
	*/
	void sweepRegionCount(const SweepDescription&, const Format::SizeVec2&,
		Format::Radius_t, std::span<const Format::Region_t>);

};

}